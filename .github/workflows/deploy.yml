name: Deploy

# Deployment Workflow
# This workflow handles deployment to different environments and platforms

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      platform:
        description: 'Deployment platform'
        required: true
        default: 'vercel'
        type: choice
        options:
          - vercel
          - netlify
          - aws
      force_deploy:
        description: 'Force deployment (skip tests)'
        required: false
        default: false
        type: boolean
  push:
    branches: [main, develop]
    paths:
      - 'src/**'
      - 'package.json'
      - 'package-lock.json'
      - 'next.config.*'
      - '.env.example'
  pull_request:
    types: [closed, merged]

env:
  NODE_VERSION: '18'
  CACHE_VERSION: v1

jobs:
  # Pre-deployment checks
  pre-deploy:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch'
    outputs:
      should_deploy: ${{ steps.changes.outputs.should_deploy }}
      deploy_environment: ${{ steps.environment.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Check for file changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            src:
              - 'src/**'
            config:
              - 'package.json'
              - 'next.config.*'
              - '.env.example'
              
      - name: Determine deployment environment
        id: environment
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
          fi
          
      - name: Should deploy?
        id: should_deploy
        run: |
          if [ "${{ steps.environment.outputs.environment }}" != "none" ] && \
             [ "${{ steps.changes.outputs.src }}" == "true" ] || \
             [ "${{ steps.changes.outputs.config }}" == "true" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi
          
  # Security and dependency checks
  security-check:
    name: Security & Dependency Check
    runs-on: ubuntu-latest
    needs: pre-deploy
    if: needs.pre-deploy.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ env.CACHE_VERSION }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.CACHE_VERSION }}-
            
      - name: Install dependencies
        run: npm ci
        
      - name: Run security audit
        run: |
          echo "üîç Running security audit..."
          npm audit --audit-level=moderate --json > security-audit.json || true
          
          # Check for high/critical vulnerabilities
          high_vulns=$(jq -r '.vulnerabilities | map(select(.severity == "high")) | length' security-audit.json 2>/dev/null || echo "0")
          critical_vulns=$(jq -r '.vulnerabilities | map(select(.severity == "critical")) | length' security-audit.json 2>/dev/null || echo "0")
          
          if [ "$high_vulns" -gt 0 ] || [ "$critical_vulns" -gt 0 ]; then
            echo "‚ùå Security vulnerabilities found!"
            echo "High: $high_vulns, Critical: $critical_vulns"
            exit 1
          else
            echo "‚úÖ No high/critical vulnerabilities found"
          fi
          
      - name: Check for outdated dependencies
        run: |
          echo "üì¶ Checking for outdated dependencies..."
          npm outdated --json > outdated.json || true
          
          outdated_count=$(jq -r '. | length' outdated.json 2>/dev/null || echo "0")
          if [ "$outdated_count" -gt 0 ]; then
            echo "‚ö†Ô∏è Found $outdated_count outdated dependencies"
            jq -r '.[] | "\(.name): current \(.current), latest \(.latest)"' outdated.json 2>/dev/null || true
          else
            echo "‚úÖ All dependencies are up to date"
          fi
          
      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: |
            security-audit.json
            outdated.json
          retention-days: 30
          
  # Build application
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [pre-deploy, security-check]
    if: needs.pre-deploy.outputs.should_deploy == 'true'
    outputs:
      build_path: ${{ steps.build.outputs.build_path }}
      build_url: ${{ steps.build.outputs.build_url }}
    
    strategy:
      matrix:
        node-version: [16, 18, 20]
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          
      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ env.CACHE_VERSION }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.CACHE_VERSION }}-
            
      - name: Install dependencies
        run: npm ci
        
      - name: Run tests (unless forced)
        if: github.event.inputs.force_deploy != 'true'
        run: |
          echo "üß™ Running tests before deployment..."
          npm run test:coverage
          
      - name: Build application
        id: build
        run: |
          echo "üèó Building application..."
          
          # Set environment-specific build variables
          if [ "${{ needs.pre-deploy.outputs.deploy_environment }}" = "production" ]; then
            export NODE_ENV=production
            export ANALYZE=false
          else
            export NODE_ENV=staging
            export ANALYZE=true
          fi
          
          # Build the application
          npm run build
          
          # Output build information
          echo "build_path=.next" >> $GITHUB_OUTPUT
          echo "build_url=${{ steps.build.outputs.url || 'N/A' }}" >> $GITHUB_OUTPUT
          
      - name: Generate build metadata
        id: metadata
        run: |
          echo "commit=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          echo "environment=${{ needs.pre-deploy.outputs.deploy_environment }}" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -Iseconds)" >> $GITHUB_OUTPUT
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ needs.pre-deploy.outputs.deploy_environment }}-${{ github.sha }}
          path: |
            .next/
            !.next/cache/
          retention-days: 7
          
      - name: Bundle analysis
        if: needs.pre-deploy.outputs.deploy_environment == 'staging'
        run: |
          echo "üìä Analyzing bundle size..."
          npm run bundle:analyze
          
      - name: Upload bundle analysis
        if: needs.pre-deploy.outputs.deploy_environment == 'staging'
        uses: actions/upload-artifact@v4
        with:
          name: bundle-analysis-${{ needs.pre-deploy.outputs.deploy_environment }}-${{ github.sha }}
          path: .next/analyze/
          retention-days: 7
          
  # Deploy to Vercel
  deploy-vercel:
    name: Deploy to Vercel
    runs-on: ubuntu-latest
    needs: [build]
    if: |
      needs.build.result == 'success' && (
        github.event.inputs.platform == 'vercel' ||
        (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
        (github.event_name == 'push' && github.ref == 'refs/heads/develop')
      )
    environment: ${{ needs.pre-deploy.outputs.deploy_environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ needs.pre-deploy.outputs.deploy_environment }}-${{ github.sha }}
          path: .next/
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      - name: Install Vercel CLI
        run: npm install -g vercel
        
      - name: Deploy to Vercel
        id: deploy
        run: |
          echo "üöÄ Deploying to Vercel..."
          
          # Set Vercel project ID and org ID from secrets
          export VERCEL_ORG_ID="${{ secrets.VERCEL_ORG_ID }}"
          export VERCEL_PROJECT_ID="${{ secrets.VERCEL_PROJECT_ID }}"
          
          # Deploy based on environment
          if [ "${{ needs.pre-deploy.outputs.deploy_environment }}" = "production" ]; then
            vercel --prod --confirm
          else
            vercel --confirm
          fi
          
          # Get deployment URL
          DEPLOY_URL=$(vercel ls $VERCEL_PROJECT_ID 2>/dev/null | grep -E 'https://.*\.vercel\.app' | head -1 || echo "")
          echo "deploy_url=$DEPLOY_URL" >> $GITHUB_OUTPUT
          
      - name: Update deployment status
        if: always()
        run: |
          if [ -n "${{ steps.deploy.outputs.deploy_url }}" ]; then
            echo "‚úÖ Deployment successful!"
            echo "üåê URL: ${{ steps.deploy.outputs.deploy_url }}"
          else
            echo "‚ùå Deployment failed!"
            exit 1
          fi
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          
  # Deploy to Netlify
  deploy-netlify:
    name: Deploy to Netlify
    runs-on: ubuntu-latest
    needs: [build]
    if: |
      needs.build.result == 'success' && (
        github.event.inputs.platform == 'netlify' ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.platform == 'netlify')
      )
    environment: ${{ needs.pre-deploy.outputs.deploy_environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ needs.pre-deploy.outputs.deploy_environment }}-${{ github.sha }}
          path: .next/
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      - name: Install Netlify CLI
        run: npm install -g netlify-cli
        
      - name: Deploy to Netlify
        id: deploy
        run: |
          echo "üöÄ Deploying to Netlify..."
          
          # Deploy based on environment
          if [ "${{ needs.pre-deploy.outputs.deploy_environment }}" = "production" ]; then
            netlify deploy --prod --dir=.next
          else
            netlify deploy --dir=.next
          fi
          
          # Get deployment URL
          DEPLOY_URL=$(netlify status | grep -E 'Website URL:|' | cut -d' ' -f2 || echo "")
          echo "deploy_url=$DEPLOY_URL" >> $GITHUB_OUTPUT
          
      - name: Update deployment status
        if: always()
        run: |
          if [ -n "${{ steps.deploy.outputs.deploy_url }}" ]; then
            echo "‚úÖ Deployment successful!"
            echo "üåê URL: ${{ steps.deploy.outputs.deploy_url }}"
          else
            echo "‚ùå Deployment failed!"
            exit 1
          fi
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
          
  # Deploy to AWS
  deploy-aws:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: [build]
    if: |
      needs.build.result == 'success' && (
        github.event.inputs.platform == 'aws' ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.platform == 'aws')
      )
    environment: ${{ needs.pre-deploy.outputs.deploy_environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ needs.pre-deploy.outputs.deploy_environment }}-${{ github.sha }}
          path: .next/
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Deploy to AWS S3
        id: deploy
        run: |
          echo "üöÄ Deploying to AWS S3..."
          
          # Sync to S3
          aws s3 sync .next/ s3://${{ secrets.AWS_S3_BUCKET }}/ --delete
          
          # Invalidate CloudFront if distribution ID is provided
          if [ -n "${{ secrets.AWS_CLOUDFRONT_DISTRIBUTION_ID }}" ]; then
            aws cloudfront create-invalidation --distribution-id "${{ secrets.AWS_CLOUDFRONT_DISTRIBUTION_ID }}" --paths "/*"
          fi
          
          # Construct deployment URL
          DEPLOY_URL="https://${{ secrets.AWS_DOMAIN }}"
          echo "deploy_url=$DEPLOY_URL" >> $GITHUB_OUTPUT
          
      - name: Update deployment status
        if: always()
        run: |
          if [ -n "${{ steps.deploy.outputs.deploy_url }}" ]; then
            echo "‚úÖ Deployment successful!"
            echo "üåê URL: ${{ steps.deploy.outputs.deploy_url }}"
          else
            echo "‚ùå Deployment failed!"
            exit 1
          fi
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_DOMAIN: ${{ secrets.AWS_DOMAIN }}
          AWS_CLOUDFRONT_DISTRIBUTION_ID: ${{ secrets.AWS_CLOUDFRONT_DISTRIBUTION_ID }}
          
  # Post-deployment tests
  post-deploy-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: [deploy-vercel, deploy-netlify, deploy-aws]
    if: always() && needs.pre-deploy.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          
      - name: Wait for deployment
        run: |
          echo "‚è≥ Waiting for deployment to be ready..."
          sleep 60
          
      - name: Run smoke tests
        run: |
          echo "üß™ Running smoke tests against deployed application..."
          
          # Get deployment URL from previous job
          DEPLOY_URL=""
          if [ "${{ needs.deploy-vercel.result }}" = "success" ]; then
            DEPLOY_URL="${{ needs.deploy-vercel.outputs.deploy_url }}"
          elif [ "${{ needs.deploy-netlify.result }}" = "success" ]; then
            DEPLOY_URL="${{ needs.deploy-netlify.outputs.deploy_url }}"
          elif [ "${{ needs.deploy-aws.result }}" = "success" ]; then
            DEPLOY_URL="${{ needs.deploy-aws.outputs.deploy_url }}"
          fi
          
          if [ -n "$DEPLOY_URL" ]; then
            # Run basic smoke tests
            curl -f "$DEPLOY_URL" | grep -q "html" || {
              echo "‚ùå Smoke tests failed - application not responding"
              exit 1
            }
            
            echo "‚úÖ Smoke tests passed"
          else
            echo "‚ö†Ô∏è No deployment URL found, skipping smoke tests"
          fi
          
      - name: Run E2E tests
        if: needs.pre-deploy.outputs.deploy_environment == 'production'
        run: |
          echo "üé≠ Running E2E tests against production..."
          npm run test:e2e
        env:
          CYPRESS_BASE_URL: ${{ needs.deploy-vercel.outputs.deploy_url || needs.deploy-netlify.outputs.deploy_url || needs.deploy-aws.outputs.deploy_url }}
          
  # Deployment notification
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [post-deploy-tests]
    if: always() && needs.pre-deploy.outputs.should_deploy == 'true'
    
    steps:
      - name: Notify deployment status
        run: |
          echo "üì¢ Sending deployment notification..."
          
          # Determine deployment status
          STATUS="failed"
          EMOJI="‚ùå"
          
          if [ "${{ needs.deploy-vercel.result }}" = "success" ] || \
             [ "${{ needs.deploy-netlify.result }}" = "success" ] || \
             [ "${{ needs.deploy-aws.result }}" = "success" ]; then
            STATUS="successful"
            EMOJI="‚úÖ"
          fi
          
          # Get deployment URL
          DEPLOY_URL=""
          if [ "${{ needs.deploy-vercel.result }}" = "success" ]; then
            DEPLOY_URL="${{ needs.deploy-vercel.outputs.deploy_url }}"
          elif [ "${{ needs.deploy-netlify.result }}" = "success" ]; then
            DEPLOY_URL="${{ needs.deploy-netlify.outputs.deploy_url }}"
          elif [ "${{ needs.deploy-aws.result }}" = "success" ]; then
            DEPLOY_URL="${{ needs.deploy-aws.outputs.deploy_url }}"
          fi
          
          echo "$EMOJI Deployment $STATUS to ${{ needs.pre-deploy.outputs.deploy_environment }}"
          echo "üåê URL: $DEPLOY_URL"
          echo "üìÖ Time: $(date)"
          echo "üë§ Deployed by: ${{ github.actor }}"
          echo "üîó Commit: ${{ github.sha }}"
          
          # You can add Slack, Discord, or email notifications here
          # Example for Slack webhook:
          # curl -X POST -H 'Content-type: application/json' \
          #   --data "{\"text\":\"$EMOJI Deployment $STATUS to ${{ needs.pre-deploy.outputs.deploy_environment }}\\nüåê $DEPLOY_URL\\nüìÖ $(date)\\nüë§ ${{ github.actor }}\\nüîó ${{ github.sha }}\"}" \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}